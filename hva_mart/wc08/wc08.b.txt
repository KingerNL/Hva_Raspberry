~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Opdracht 8.b ncursesio
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Voor het stabieler functioneren van een besturingssysteem is het belangrijk 
dat alle invoer van het gehele systeem via het besturingssysteem verloopt. Op 
deze manier kan het besturingssysteem bijvoorbeeld speciale toetscombinaties 
afvangen en de invoer doorsturen naar het actieve programma. Met een 
toetscombinatie zoals ALT+TAB of ALT+F# kan de gebruiker hierdoor steeds een 
ander programma actief maken.

Combineer de invoer via ncurses met de bewerking van door de Xmega (opdracht 
8a) en toon de verkregen waarden.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Hardware 
* Laptop
* Raspberry Pi

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Software 
*	Via ssh-sessie: gcc
*	Via ssh-sessie: g++
*	Via ssh-sessie: nano, vi, … 
*	Via drive-mapping: Notepad++, Visual Code, …
*	Aantal TODO’s: 2

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Folders en bestanden:
08.b/ncursesio.cpp                                                 aangeleverd
08.b/ncursesio.hpp                                                 aangeleverd
08.b/hello-xmega-lib.cpp                                           aangeleverd
08.b/hello-xmega-lib.hpp                                           aangeleverd
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



ncursesio.cpp
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 8.b ncursesio
//
// g++ -Wall -lncurses -o ncursesio ncursesio.cpp hello-xmega-lib.cpp
// ./ncursesio

//TODO: zorg voor de juiste include

int main(int argc, char* argv[]) {

  char sUsbName[] = "/dev/ttyACM0";
  int nKey;
  bool bExit;
  uint8_t nByte;

  // Initialiseren
  initscr();
  clear();
  noecho();
  cbreak();
  raw();
  keypad(stdscr, true);
  nodelay(stdscr, true);

  printw("w4.2.2ncursesio\n\n"); refresh();

  // Initialiseer de correct Xmega-connectie (B38400 B57600 B115200)
  printw("> Verbinden: ");
  if (!InitXmegaSerial(sUsbName, B115200, 0)) {
    endwin();
    printf("Geen Xmega gevonden!\n");
    return -1;
  }
  else {
    printw(" OK\n");
  };
  refresh();

  // Blijf opvragen, versturen en tonen
  bExit = false;
  while (!bExit) {

    nKey = getch();

    // Exit is ESC
    if (nKey == 27) {
      bExit = true;
    };

    // Verwerk de toetsaanslag
    if (nKey != -1) {
      mvprintw(5,5, "Toets: %d=%c    ", nKey, nKey); refresh();
      XmegaWriteByte((uint8_t*)&nKey);
      while (!XmegaReadByte(&nByte));
      mvprintw(6,5, "Xmega: %d=%c    ", nByte, nByte); refresh();
    };
  };
  
  // Afsluiten
  endwin();
  printf("Afgesloten :-) ");
  if (!CloseXmegaSerial()) {
    printf(" fout\n");
  }
  else {
    printf(" OK\n");
  };

  return 0;
};



ncursesio.hpp
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 8.b ncursesio

#ifndef _NCURSESIO_HPP_
#define _NCURSESIO_HPP_

  //TODO: zorg dat ncurses beschikbaar is
  #include <stdbool.h>
  #include <stdio.h>
  #include <stdint.h>
  #include <string.h>
  #include <time.h>
  #include "hello-xmega-lib.hpp"

  // Maak #define voor handige delay-functie in msec
  #define thread_delay(nMSec) \
  { \
    struct timespec oTime, oTimeLeft; \
    oTime.tv_sec = 0; \
    oTime.tv_nsec = (nMSec) * 1000000L; \
    nanosleep(&oTime, &oTimeLeft); \
  };

#endif // _NCURSESIO_HPP_



hello-xmega-lib.cpp
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include "hello-xmega-lib.hpp"

int _nSerial = 0;

bool InitXmegaSerial(char* pTtyAcm, int nBaudrate, int nParity) {

  struct termios oTty;

  // A possible string?
  if (pTtyAcm == NULL) {
		printf("No valid device name!\n");
		return false; 
  }

  // Try to open the serial connection
  printf("[%s] ", pTtyAcm);
  _nSerial = open(pTtyAcm, O_RDWR | O_NOCTTY | O_NONBLOCK);
	if (_nSerial == 0)
	{
		perror(pTtyAcm);
		printf("Failed to open device: %s\n", pTtyAcm);
		return false; 
	}

  // Clear struct to start with new settings
  memset(&oTty, 0, sizeof(oTty));
  if (tcgetattr(_nSerial, &oTty) != 0) {
    printf("Error %i getting settings: %s\n", errno, strerror(errno));
    return false;
  };

  // Init minimal serial settings for noncannonical mode (no extra character processing)
  oTty.c_iflag = 0; // Input
  oTty.c_oflag = 0; // Output
  oTty.c_lflag = 0; // Line
  oTty.c_cflag = CS8 | CREAD | CLOCAL; // Character
  oTty.c_cc[VMIN] = 1; // Length
  oTty.c_cc[VTIME] = 0; // Timeout

  // Init speed: use default constants
  if (cfsetispeed(&oTty, nBaudrate) < 0) {
    printf("Error %i setting input speed: %s\n", errno, strerror(errno));
    return false;
  };
  if (cfsetospeed(&oTty, nBaudrate) < 0) {
    printf("Error %i setting output speed: %s\n", errno, strerror(errno));
    return false;
  };

  // Set new settings NOW
  if (tcsetattr(_nSerial, TCSANOW, &oTty) < 0) {
    printf("Error %i setting settings: %s\n", errno, strerror(errno));
    return false;
  };
  
  // Flush input and output buffers
  if (tcflush(_nSerial, TCIOFLUSH) < 0) {
    printf("Error %i flushing input and output: %s\n", errno, strerror(errno));
    return false;
  };

  return true;
};

bool XmegaReadByte(uint8_t* nByte) {

  ssize_t nSize;

  // Check for valid open connection
  if (_nSerial == 0) {
    return false;
  }

  // Read one byte only
  nSize = read(_nSerial, nByte, 1);
  if (nSize == -1 && errno == 11) {
    return false;
  }
  if (nSize == 0) {
    return false;
  }

  if (nSize == -1) {
    printf("Error reading: %s", strerror(errno));
    return false;
  }

  return true;
};

bool XmegaWriteByte(uint8_t* nByte) {

  ssize_t nSize;

  // Check for valid open connection
  if (_nSerial == 0) {
    return false;
  }

  // Read one byte only
  nSize = write(_nSerial, nByte, 1);
  if (nSize != 1) {
    return false;
  };

  return true;
};

bool CloseXmegaSerial() {

  if (_nSerial != 0) {
    close(_nSerial);
  }

  return true;
};



hello-xmega-lib.hpp
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#ifndef _HELLO_XMEGA_LIB_HPP_
#define _HELLO_XMEGA_LIB_HPP_

  #include <stdio.h>
  #include <string.h>
  #include <fcntl.h>
  #include <errno.h>
  #include <termios.h>
  #include <unistd.h>
  
  #include <stdbool.h>
  #include <stdint.h>
  #include <stdlib.h>	

  bool InitXmegaSerial(char* pTtyAcm, int nBaudrate, int nParity);
  bool XmegaReadByte(uint8_t* nByte);
  bool XmegaWriteByte(uint8_t* nByte);
  bool CloseXmegaSerial();

#endif // _HELLO_XMEGA_LIB_HPP_

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Opdracht 7.b paging
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Voor verschillende taken biedt het besturingssysteem een ‘opbergkast’ met een 
‘inhoudsopgave’ aan. Bijvoorbeeld voor: 

* Geheugenbeheer: elk programma krijgt zijn eigen geheugen voor de uitvoering.
* Bestandssysteem: in FAT en NTFS wordt een bestand in bokken gehakt en 
  geplaatst in sectoren (de blokken op de disk). Aanvullend wordt er ook een 
  lijst bijgehouden in welke sectoren het bestand is opgeslagen.

In een microcontroller omgeving kan dit mechaniek ook gebruikt worden om zelf 
een eenvoudige administratie op te zetten en bij te houden.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Hardware 
* Laptop
* Raspberry Pi

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Software 
*	Via ssh-sessie: gcc
*	Via ssh-sessie: g++
*	Via ssh-sessie: nano, vi, … 
*	Via drive-mapping: Notepad++, Visual Code, …
*	Aantal TODO’s: 7.b paging

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Folders en bestanden:
07.b/paging.cpp                                                    aangeleverd
07.b/paging.hpp                                                    aangeleverd
07.b/blokbuffer.cpp                                                aangeleverd
07.b/blokbuffer.hpp                                                aangeleverd
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



paging.cpp
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 7.b paging
//
// g++ -Wall -o paging paging.cpp blokbuffer.cpp
// ./paging

#include "paging.hpp"

int main(int nArgc, char* aArgv[]) {

  char sTekst1[] = "Hallo blok buffer";
  char sTekst2[] = "De tweede tekst";
  char sTekst3[] = "Op de eerste index?";
  unsigned int nIndex1, nIndex2, nIndex3;

  // Initialiseren
  printf("7.b paging\n\n");
  //TODO: maak variabele oBlok van type Blokbuffer van 10 lang en blokformaat 128
  
  printf("> lengte=%d blok=%d isleeg=%c isvol=%c\n", oBlok.lengte(), oBlok.blok(), oBlok.isLeeg() ? 'j' : 'n', oBlok.isVol() ? 'j' : 'n');

  // Voeg eerste tekst data toe: zal index 0 zijn
  oBlok.toevoegen(sTekst1, strlen(sTekst1), &nIndex1);
  printf("> %d = [%s]\n", nIndex1, (unsigned char*)oBlok[nIndex1]);

  // Voeg tweede tekst data toe: zal index 1 zijn
  oBlok.toevoegen(sTekst2, strlen(sTekst2), &nIndex2);
  printf("> %d = [%s]\n", nIndex2, (unsigned char*)oBlok[nIndex2]);

  // Voeg derde tekst data toe: zal index 0 zijn
  oBlok.maakVrij(0);
  oBlok.toevoegen(sTekst3, strlen(sTekst3), &nIndex3);
  printf("> %d = [%s]\n", nIndex3, (unsigned char*)oBlok[nIndex3]);

  // Afsluiten
  printf("> lengte=%d blok=%d isleeg=%c isvol=%c\n", oBlok.lengte(), oBlok.blok(), oBlok.isLeeg() ? 'j' : 'n', oBlok.isVol() ? 'j' : 'n');
  printf("\nAfgesloten :-)\n\n");

  return 0;
};



paging.hpp
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 7.b paging

#ifndef _PAGING_HPP_
#define _PAGING_HPP_

  #include <stdbool.h>
  #include <stdio.h>
  #include <string.h>
  #include <time.h>
  //TODO: zorg dat de Blokbuffer class bekend is

  // Maak #define voor handige delay-functie in msec
  #define thread_delay(nMSec) \
  { \
    struct timespec oTime, oTimeLeft; \
    oTime.tv_sec = 0; \
    oTime.tv_nsec = (nMSec) * 1000000L; \
    nanosleep(&oTime, &oTimeLeft); \
  };

//TODO: zorg voor het juiste #-commando



blokbuffer.cpp
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 7.b paging

#include "blokbuffer.hpp"

Blokbuffer::Blokbuffer(unsigned int nLengte, unsigned int nBlok) {

  // Onthoud de instellingen en alloceer het geheugen
  nLengte_ = nLengte;
  nBlok_ = nBlok;
  pBuffer_ = new unsigned char[nLengte_ * nBlok_];
  //TODO: alloceer C++ stijl een array van nLengte_ lang en type bool
  pBufferVrij_ = 
  memset(pBufferVrij_, true, nLengte_);
};

Blokbuffer::~Blokbuffer() {

  // Geheugen vrijgeven
  delete[] pBuffer_;
  delete[] pBufferVrij_;
};

unsigned int Blokbuffer::lengte() {

  return nLengte_;
};

unsigned int Blokbuffer::blok() {

  return nBlok_;
};

bool Blokbuffer::isLeeg() {

  for (unsigned int i = 0; i < nLengte_; i++) {
    if (!pBufferVrij_[i]) {
      return false;
    };
  };

  return true;
};

bool Blokbuffer::isVol() {

  for (unsigned int i = 0; i < nLengte_; i++) {
    if (pBufferVrij_[i]) {
      return false;
    };
  };

  return true;
};

bool Blokbuffer::isVrij(unsigned int nIndex) {

  return pBufferVrij_[nIndex];
};

void Blokbuffer::maakVrij(unsigned int nIndex) {

  pBufferVrij_[nIndex] = true;
};

unsigned int Blokbuffer::toevoegen(void* pData, unsigned int nData, unsigned int *nIndex) {

  // Zoek een vrije index
  *nIndex = 0;
  while (*nIndex < nLengte_ && !pBufferVrij_[*nIndex]) {
    (*nIndex)++;
  };
  if (*nIndex == nLengte_) {
    return 0;
  }

  // Kopieer de nieuwe data met max van nBlok_
  nData = nData < nBlok_ ? nData : nBlok_;
  memcpy(&pBuffer_[(*nIndex) * nBlok_], pData, nData);
  
  // Markeer bezet
  pBufferVrij_[*nIndex] = false;

  return nData;
};

void *Blokbuffer::operator[](unsigned int nIndex) {

  return &pBuffer_[nIndex * nBlok_];
};



blokbuffer.hpp
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 7.b paging

#ifndef _BLOKBUFFER_HPP_
#define _BLOKBUFFER_HPP_

  #include <stdbool.h>
  #include <stdio.h>
  #include <string.h>

  // De pagina buffer class
  class Blokbuffer {
    public:
      Blokbuffer(unsigned int nLengte, unsigned int nBlok);
      ~Blokbuffer();
      unsigned int lengte();
      unsigned int blok();
      bool isLeeg();
      //TODO: zorg dat functies isVol() en isVrij public beschikbaar zijn
      void maakVrij(unsigned int nIndex);
      unsigned int toevoegen(void* pData, unsigned int nData, unsigned int *nIndex);
      void *operator[](unsigned int nIndex);

    private:
      unsigned int nLengte_;
      unsigned int nBlok_;
      unsigned char *pBuffer_;
      bool *pBufferVrij_;
  };

#endif // _BLOKBUFFER_HPP_